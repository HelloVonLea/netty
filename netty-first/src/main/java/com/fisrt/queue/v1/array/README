首先，书写了ArrayQueue1的代码，然后在ArrayQueue1Test中进行了测试。
然后，改进了ArrayQueue1得到ArrayQueue2，在ArrayQueue2Test中进行了测试。
之后，发现ArrayQueue2中存在并发问题，加锁改进得到ArrayQueue4。在ArrayQueue4Test中进行了测试。
在测试的时候，发现加锁后，生产者在满了的情况下不能等待，并排查了问题。
最终在ArrayQueue5中解决了问题。请看《20211014问题排查总结》。
ArrayQueue5虽然保证了正确性，但是性能不够。必须去锁。
于是我们引入无锁循环数组队列。
在探索无锁队列的时候，引用过AtomicReferenceArray以及Atomic原子类。
但是，他们都只能保证当前field是正确的，组合在一起就不行了。
主要问题在于：
1.想去网上直接找答案，找一个无锁循环数组的算法。
事实上没有找到一个合适的。
2.自己写，发现难度太大。延用之前的代码并没有写出来。
不得已，自己克服困难，啃下源码。

首先，写出了MpmcArrayQueueTest对MpmcArrayQueue进行了测试，发现可以。
于是，我们把MpmcArrayQueue的代码搬了过来。
MpmcArrayQueue的源码比较晦涩难懂，原因在于，
1.单论MpmcArrayQueue就有很多方法，看到这么多方法很多人就放弃了。
如果抛弃掉我们不用的方法，只看需要的方法，东西一下少很多。
2.看方法时发现里面的参数，调用的方法都不知道什么意思，
也不知道每一步在干什么，难。
3.方法的构造参数不停的调用父类、父类、父类，实在太多了，
每个类干一点，每个类干一点，大脑就记不住了，糊涂了，难。
而且往往一个参数在起始的地方处理一下，父类再处理下，再处理下就很难
明白这个参数到底变成什么样了。
4.父类太多，不知道哪个类该看哪个类不该看，而且往往不明白每个类干了什么。
如MpmcArrayQueueL3Pad，不明白缓存行的话，不明白这个类的作用。
5.属性field每个类放一点，造成不容易看。
6.实现继承的类太多，功能太多，代码写的东西比较多，很多人看不懂。
7.多很多的知识点其实是不懂的，要么是似是而非的状况，要么是不懂其
怎么实现的。看不懂的原因就是自己不知道其原理。没写过。
8.为啥复杂？它把很多东西进行了拆分，放在了不同的类中，写进了不同的
方法，把你熟悉的东西先变成你陌生的，在把你陌生的进行变化更改，你
就很难一下就明白了。同时注释日志很少。一生二，二生三，三则纷繁复杂了。
而且它的东西，网上很少有资料，即使有资料你看不明白。就难了。

针对上面的问题，可以这么解决。
1.把源码的类，咱们仿写一遍，但是是简单版的。
比如把MpmcArrayQueue仿写成MyMpmcArrayQueue。
然后继承自谁，把继承的类仿写出来，有的类是没必要的，就略过。
如MpmcArrayQueueL3Pad,这样就可以清晰的看出类的关系。
2.仿写出类的字段field，字段是很有必要的，删除掉不必要的，剩下的字段
就很清晰的展现在你面前。
3.仿写出类的构造方法，选一个就好，因为构造方法都最终会调这一个。
通过构造方法的仿写，你就明白初始化的时候是什么样的。
4.仿写出类的方法。这个方法是你不明白的，你需要看的，仿写一下你就
有印象了，知道大致的流程。
5.在仿写的过程中，肯定有很多你不明白的地方，怎么办。一个一个的攻破。
比如它在计算容量的时候，看不懂它的算法，怎么办？
网上找资料，自己动手画图，写上代码测试，观察，最终把这个点啃下来。
之后你就明白了。
6.对于没有资料的地方，注释也晦涩难懂的地方，需要你去举例，具体化。
用具体的事物去探索原理。毕竟发明算法比较难，搞懂它不是那么难。


MpmcArrayQueue的原理。
自旋和CAS+无限长的指针+一个long数组
自旋CAS保证操作的原子性
两个volatile+long的指针保证了可见性、无限性
两个指针可以无限的增长，通过取余映射到数组下标
一个long数组保证了数据的不覆盖。








